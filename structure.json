{
  "src": {
    "app.module.ts": "// Importamos el decorador Module de @nestjs/common\r\nimport { Module } from '@nestjs/common';\r\n// Importamos otros módulos que se usarán en este módulo principal\r\nimport { ProjectsModule } from './projects/projects.module';\r\nimport { UsersModule } from './users/users.module';\r\nimport { TaskModule } from './task/task.module';\r\n// Importamos los controladores\r\nimport { HelloController } from './hello/hello.controller';\r\n\r\n@Module({\r\n  // Importamos otros módulos para que estén disponibles en el módulo principal\r\n  imports: [ProjectsModule, UsersModule, TaskModule, ],\r\n  // Declaramos los controladores que pertenecen a este módulo\r\n  controllers: [HelloController, ],\r\n})\r\n// Exportamos la clase AppModule como el módulo principal de la aplicación\r\nexport class AppModule {}\r\n",
    "hello": {
      "hello.controller.spec.ts": "import { Test, TestingModule } from '@nestjs/testing';\r\nimport { HelloController } from './hello.controller';\r\n\r\ndescribe('HelloController', () => {\r\n  let controller: HelloController;\r\n\r\n  beforeEach(async () => {\r\n    const module: TestingModule = await Test.createTestingModule({\r\n      controllers: [HelloController],\r\n    }).compile();\r\n\r\n    controller = module.get<HelloController>(HelloController);\r\n  });\r\n\r\n  it('should be defined', () => {\r\n    expect(controller).toBeDefined();\r\n  });\r\n});\r\n",
      "hello.controller.ts": "// Importamos los decoradores y clases necesarias de @nestjs/common\r\nimport { Controller, Get, Req, Res, HttpCode, Param, ParseIntPipe, ParseBoolPipe } from '@nestjs/common';\r\n// Importamos las interfaces Request y Response de express\r\nimport { Request, Response } from 'express';\r\n\r\n// Usamos el decorador @Controller para definir un controlador que maneja las rutas que comienzan con '/hello'\r\n@Controller('/hello')\r\nexport class HelloController {\r\n  // Definimos una ruta GET utilizando el decorador @Get\r\n  @Get()\r\n  index(@Req() req: Request, @Res() res: Response) {\r\n    // Enviamos una respuesta JSON con el mensaje 'Hello World' y un estado 200 (OK)\r\n    res.status(200).json({ message: 'Hello World' });\r\n  }\r\n\r\n  // Definimos una ruta GET para '/hello/notfound' utilizando el decorador @Get\r\n  @Get('notfound')\r\n  @HttpCode(404) // Especificamos que esta ruta debe devolver un código de estado 404\r\n  notFoundPage() {\r\n    // Retornamos el mensaje '404 not found'\r\n    return '404 not found';\r\n  }\r\n\r\n  // Definimos una ruta GET para '/hello/error' utilizando el decorador @Get\r\n  @Get('error')\r\n  @HttpCode(500) // Especificamos que esta ruta debe devolver un código de estado 500\r\n  errorPage() {\r\n    // Retornamos el mensaje 'error del servidor'\r\n    return 'error del servidor';\r\n  }\r\n\r\n  // Definimos una ruta GET para '/hello/error' utilizando el decorador @Get\r\n  @Get('new')\r\n  @HttpCode(201) // Especificamos que esta ruta debe devolver un código de estado 500\r\n  sendData() {\r\n    // Retornamos el mensaje 'error del servidor'\r\n    return 'EnvioCorrecto';\r\n  }\r\n  @Get('ticket/:num')\r\n  getNumber(@Param('num', ParseIntPipe) num: number) {\r\n    return num+14;\r\n  }\r\n  @Get('active/:status')\r\n  getStatus(@Param('status', ParseBoolPipe) status: boolean) {\r\n    console.log(typeof status);\r\n    return status;\r\n  }\r\n\r\n  \r\n}\r\n\r\n",
      "pipes": {
        "validateuser": {
          "validateuser.pipe.spec.ts": "import { ValidateuserPipe } from './validateuser.pipe';\r\n\r\ndescribe('ValidateuserPipe', () => {\r\n  it('should be defined', () => {\r\n    expect(new ValidateuserPipe()).toBeDefined();\r\n  });\r\n});\r\n",
          "validateuser.pipe.ts": "import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';\r\n\r\n@Injectable()\r\nexport class ValidateuserPipe implements PipeTransform {\r\n  transform(value: any, metadata: ArgumentMetadata) {\r\n    return value;\r\n  }\r\n}\r\n"
        }
      }
    },
    "main.ts": "import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from './app.module';\r\nimport { ValidationPipe } from '@nestjs/common';\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n  // Agregar uso global de pipes\r\n  app.useGlobalPipes(new ValidationPipe(\r\n    {whitelist: true,}\r\n  ));\r\n\r\n  await app.listen(3000);\r\n}\r\nbootstrap();\r\n",
    "projects": {
      "projects.controller.spec.ts": "import { Test, TestingModule } from '@nestjs/testing';\r\nimport { ProjectsController } from './projects.controller';\r\n\r\ndescribe('ProjectsController', () => {\r\n  let controller: ProjectsController;\r\n\r\n  beforeEach(async () => {\r\n    const module: TestingModule = await Test.createTestingModule({\r\n      controllers: [ProjectsController],\r\n    }).compile();\r\n\r\n    controller = module.get<ProjectsController>(ProjectsController);\r\n  });\r\n\r\n  it('should be defined', () => {\r\n    expect(controller).toBeDefined();\r\n  });\r\n});\r\n",
      "projects.controller.ts": "import { Controller } from '@nestjs/common';\r\n\r\n@Controller('projects')\r\nexport class ProjectsController {}\r\n",
      "projects.module.ts": "import { Module } from '@nestjs/common';\r\nimport { ProjectsController } from './projects.controller';\n\r\n@Module({\n  controllers: [ProjectsController]\n})\r\nexport class ProjectsModule {}\r\n"
    },
    "task": {
      "dto": {
        "create-task.dto.ts": "// Importamos los decoradores IsString y MinLength de class-validator\r\nimport { IsString, Min, MinLength } from 'class-validator';\r\n\r\n// Definimos la clase DTO para crear una tarea\r\nexport class CreateTaskDto {\r\n  // Validamos que el campo title sea una cadena de texto y tenga una longitud mínima de 1\r\n  @IsString()\r\n  @MinLength(1)\r\n  title: string;\r\n\r\n  // Validamos que el campo descripción sea una cadena de texto y tenga una longitud mínima de 1\r\n  @IsString()\r\n  @MinLength(1)\r\n  descripcion: string;\r\n}\r\n",
        "update-task.dto.ts": "export interface UpdateTaskDto{\r\n    title?:string;\r\n    descripcion?:string;\r\n}"
      },
      "task.controller.ts": "import { CreateTaskDto } from './dto/create-task.dto';\r\n// Importamos los decoradores y clases necesarias de @nestjs/common\r\nimport {\r\n  Controller,\r\n  Get,\r\n  Post,\r\n  Put,\r\n  Patch,\r\n  Delete,\r\n  Body,\r\n  Query,\r\n  Param,\r\n  UsePipes,\r\n  ValidationPipe\r\n} from '@nestjs/common';\r\n// Importamos el servicio TaskService\r\nimport { TaskService } from './task.service';\r\nimport { UpdateTaskDto } from './dto/update-task.dto';\r\n\r\n// Definimos un controlador usando el decorador @Controller\r\n@Controller('/task')\r\nexport class TaskController {\r\n  // Inyectamos el servicio TaskService mediante el constructor\r\n  constructor(private TaskService: TaskService) {}\r\n\r\n  // Definimos una ruta GET para '/task' utilizando el decorador @Get\r\n  @Get()\r\n  getAllTask(@Query() query: any) {\r\n    console.log(query);\r\n    // Llamamos al método getTasks del servicio TaskService y devolvemos su resultado\r\n    return this.TaskService.getTasks();\r\n  }\r\n\r\n  @Get('/:id') //task/2 o task/3 o task/4\r\n  getTask(@Param('id') id:string) {\r\n    return this.TaskService.getTask(parseInt(id));\r\n  }\r\n\r\n  // Definimos una ruta POST para '/task' utilizando el decorador @Post\r\n  @Post()\r\n  @UsePipes(new ValidationPipe())\r\n  postTask(@Body() task: CreateTaskDto) {\r\n    // Llamamos al método createTask del servicio TaskService y devolvemos su resultado\r\n    return this.TaskService.createTask(task);\r\n  }\r\n\r\n  // Definimos una ruta Put para '/task' utilizando el decorador @Put\r\n  @Put()\r\n  putTask(@Body() task: any) {\r\n    return this.TaskService.putTask(task);\r\n  }\r\n\r\n  // Definimos una ruta Patch para '/task' utilizando el decorador @Patch\r\n  @Patch()\r\n  patchTask(@Body() task: UpdateTaskDto) {\r\n    return this.TaskService.patchTask(task);\r\n  }\r\n\r\n  // Definimos una ruta Patch para '/task' utilizando el decorador @Patch\r\n  @Delete()\r\n  deleteTask(@Body() task: any) {\r\n    return this.TaskService.deleteTask(task);\r\n  }\r\n\r\n  \r\n}\r\n",
      "task.module.ts": "// Importamos el decorador Module de @nestjs/common\r\nimport { Module } from '@nestjs/common';\r\n// Importamos el controlador TaskController\r\nimport { TaskController } from './task.controller';\r\n// Importamos el servicio TaskService\r\nimport { TaskService } from './task.service';\r\n\r\n// Usamos el decorador @Module para definir un módulo en NestJS\r\n@Module({\r\n    // Declaramos los controladores que pertenecen a este módulo\r\n    controllers: [TaskController],\r\n    // Declaramos los proveedores (servicios) que pertenecen a este módulo\r\n    providers: [TaskService]\r\n})\r\n// Exportamos la clase TaskModule como un módulo de NestJS\r\nexport class TaskModule {}\r\n",
      "task.service.ts": "import { NotFoundException } from '@nestjs/common';\r\n// Importamos el decorador Injectable de @nestjs/common\r\nimport { Injectable, HttpCode } from '@nestjs/common';\r\nimport { UpdateTaskDto } from './dto/update-task.dto';\r\n\r\nexport interface User {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\n// Usamos el decorador @Injectable para marcar la clase como un proveedor de servicios en NestJS\r\n@Injectable()\r\nexport class TaskService {\r\n\r\nprivate tasks = []\r\n\r\n  // Definimos el método getTasks que devuelve una lista de tareas\r\n  getTasks() {\r\n    return this.tasks\r\n  }\r\n\r\n\r\n  getTask(id: number) {\r\n    // Busca la tarea en el arreglo `this.tasks` basándose en su `id`\r\n    const taskFound = this.tasks.find(task => task.id === id);\r\n\r\n    // Si no se encuentra la tarea, se lanza una excepción NotFoundException\r\n    if (!taskFound) {\r\n        throw new NotFoundException(`La tarea con el id ${id} no fue encontrada`);\r\n    }\r\n\r\n    // Retorna la tarea encontrada\r\n    return taskFound;\r\n}\r\n\r\n  createTask(task: any) {\r\n    // Imprimimos en la consola el cuerpo de la solicitud (el nuevo task)\r\n    console.log(task);\r\n\r\n    // Asumiendo que `this.tasks` es una propiedad del servicio donde se almacenan las tareas\r\n    const newTask = {\r\n        ...task,\r\n        id: this.tasks.length + 1, // Asumiendo que `this.tasks` es un arreglo de tareas y queremos asignar un ID único\r\n    };\r\n\r\n    this.tasks.push(newTask); // Agregamos la nueva tarea al arreglo `this.tasks`\r\n\r\n    return newTask; // Retornamos la nueva tarea creada\r\n}\r\n\r\n\r\n  putTask(task: UpdateTaskDto) {\r\n    // Imprimimos en la consola el cuerpo de la solicitud (el nuevo task)\r\n    console.log(task);\r\n    this.tasks.push(task);\r\n    return task;\r\n  }\r\n\r\n  patchTask(task: any) {\r\n    // Imprimimos en la consola el cuerpo de la solicitud (el nuevo task)\r\n    console.log(task);\r\n    this.tasks.push(task);\r\n    return task;\r\n  }\r\n\r\n  deleteTask(task: any) {\r\n    // Imprimimos en la consola el cuerpo de la solicitud (el nuevo task)\r\n    console.log(task);\r\n    this.tasks.push(task);\r\n    return task;\r\n  }\r\n}\r\n"
    },
    "users": {
      "dto": {
        "create-user-dto.ts": "// Importamos los decoradores de class-validator\r\nimport { IsString, IsEmail, IsNotEmpty, Max, IsNumber } from 'class-validator';\r\n\r\n// Definimos la clase DTO para crear un usuario\r\nexport class CreateUserDto {\r\n  // Validamos que el campo email sea un correo electrónico, una cadena de texto y no esté vacío\r\n  @IsEmail()\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  email: string;\r\n\r\n  // Validamos que el campo password sea una cadena de texto y no esté vacío\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  password: string;\r\n\r\n  // Validamos que el campo name sea una cadena de texto y no esté vacío\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  name: string;\r\n\r\n  // Validamos que el campo age sea un número y no supere 100\r\n  @IsNumber()\r\n  @Max(100)\r\n  age: number;\r\n}\r\n"
      },
      "users.controller.spec.ts": "import { Test, TestingModule } from '@nestjs/testing';\r\nimport { UsersController } from './users.controller';\r\n\r\ndescribe('UsersController', () => {\r\n  let controller: UsersController;\r\n\r\n  beforeEach(async () => {\r\n    const module: TestingModule = await Test.createTestingModule({\r\n      controllers: [UsersController],\r\n    }).compile();\r\n\r\n    controller = module.get<UsersController>(UsersController);\r\n  });\r\n\r\n  it('should be defined', () => {\r\n    expect(controller).toBeDefined();\r\n  });\r\n});\r\n",
      "users.controller.ts": "// Importamos los decoradores y clases necesarias de @nestjs/common\r\nimport { Body, Controller, Get, Post, UsePipes, ValidationPipe } from '@nestjs/common';\r\n// Importamos el servicio UsersService\r\nimport { UsersService } from './users.service';\r\n// Importamos el DTO para crear un usuario\r\nimport { CreateUserDto } from './dto/create-user-dto';\r\n\r\n// Definimos un controlador usando el decorador @Controller\r\n@Controller('/users')\r\nexport class UsersController {\r\n    // Inyectamos el servicio UsersService mediante el constructor\r\n    constructor(private UsersService: UsersService) {}\r\n\r\n    // Definimos una ruta GET utilizando el decorador @Get\r\n    @Get()\r\n    getUsers() {\r\n        // Llamamos al método getUsers del servicio UsersService y devolvemos su resultado\r\n        return this.UsersService.getUsers();\r\n    }\r\n\r\n    // Definimos una ruta POST utilizando el decorador @Post\r\n    @Post()\r\n    // Usamos el decorador @UsePipes para aplicar el ValidationPipe a la solicitud\r\n    @UsePipes(new ValidationPipe())\r\n    createUser(@Body() user: CreateUserDto) {\r\n        // Llamamos al método createUser del servicio UsersService con los datos validados y devolvemos su resultado\r\n        return this.UsersService.createUser(user);\r\n    }\r\n}\r\n",
      "users.module.ts": "import { Module } from '@nestjs/common';\r\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\n\r\n@Module({\n  controllers: [UsersController],\n  providers: [UsersService]\n})\r\nexport class UsersModule {}\r\n",
      "users.service.spec.ts": "import { Test, TestingModule } from '@nestjs/testing';\r\nimport { UsersService } from './users.service';\r\n\r\ndescribe('UsersService', () => {\r\n  let service: UsersService;\r\n\r\n  beforeEach(async () => {\r\n    const module: TestingModule = await Test.createTestingModule({\r\n      providers: [UsersService],\r\n    }).compile();\r\n\r\n    service = module.get<UsersService>(UsersService);\r\n  });\r\n\r\n  it('should be defined', () => {\r\n    expect(service).toBeDefined();\r\n  });\r\n});\r\n",
      "users.service.ts": "// Importamos el decorador Injectable de @nestjs/common\r\nimport { Injectable } from '@nestjs/common';\r\n// Importamos el DTO para crear un usuario\r\nimport { CreateUserDto } from './dto/create-user-dto';\r\n\r\n// Usamos el decorador @Injectable para marcar la clase como un proveedor de servicios en NestJS\r\n@Injectable()\r\nexport class UsersService {\r\n    // Arreglo privado para almacenar los usuarios\r\n    private users: any[] = [\r\n        {\r\n            id: 1,\r\n            name: 'Acosta',\r\n            phone: '3413153523',\r\n        },\r\n        {\r\n            id: 2,\r\n            name: 'Saccone',\r\n            phone: '3413577058',\r\n        }\r\n    ];\r\n\r\n    // Método para obtener todos los usuarios\r\n    getUsers() {\r\n        return this.users;\r\n    }\r\n\r\n    // Método para crear un nuevo usuario\r\n    createUser(user: CreateUserDto) {\r\n        // Añadimos el nuevo usuario al arreglo users\r\n        this.users.push(user);\r\n\r\n        // Devolvemos el nuevo usuario con un ID asignado\r\n        return {\r\n            ...user,\r\n            id: this.users.length + 1, // Asignamos un ID único al nuevo usuario\r\n        };\r\n    }\r\n}\r\n"
    }
  }
}